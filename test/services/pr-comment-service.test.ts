/**
 * Unit tests for PR Comment Service
 */

import { describe, it, expect, beforeEach, vi } from "vitest";
import type { AnalysisResult } from "../../src/types/index.js";

// Type definitions for better type safety
interface MockGitHubContext {
  eventName: string;
  issue: {
    number: number;
  };
  repo: {
    owner: string;
    repo: string;
  };
}

// Proper Vitest mock types to avoid "never" type issues
type MockFunction = ReturnType<typeof vi.fn>;

interface MockOctokitInstance {
  paginate?: MockFunction;
  rest: {
    repos: {
      get: MockFunction;
    };
    issues: {
      listComments: MockFunction;
      createComment: MockFunction;
      updateComment: MockFunction;
    };
    pulls: {
      createReview: MockFunction;
      createReviewComment: MockFunction;
      listReviewComments: MockFunction;
    };
  };
}

interface GitHubError extends Error {
  status?: number;
}

// Mock @actions/core
vi.mock("@actions/core", () => ({
  info: vi.fn(),
  error: vi.fn(),
  warning: vi.fn(),
  debug: vi.fn(),
}));

// Mock @actions/github
vi.mock("@actions/github", () => ({
  getOctokit: vi.fn(),
  context: {
    eventName: "pull_request",
    sha: "abc123def456",
    issue: {
      number: 123,
    },
    repo: {
      owner: "test-owner",
      repo: "test-repo",
    },
    ref: "refs/heads/main",
    serverUrl: "https://github.com",
  },
}));

// Import the mocked modules
import * as github from "@actions/github";
import {
  createOrUpdatePRComment,
  createPRReviewComments,
  isPullRequestEvent,
  getPRNumber,
  PRCommentData,
} from "../../src/services/pr-comment-service.js";
import { IssueCategory, IssueSeverity } from "@markupai/toolkit";
import { buildQuality, buildClarity, buildTone } from "../test-helpers/scores.js";

// Mock Octokit with proper typing
const mockOctokit: MockOctokitInstance = {
  rest: {
    repos: {
      get: vi.fn(),
    },
    issues: {
      listComments: vi.fn(),
      createComment: vi.fn(),
      updateComment: vi.fn(),
    },
    pulls: {
      createReview: vi.fn(),
      createReviewComment: vi.fn(),
      listReviewComments: vi.fn(),
    },
  },
};

// Test data factory functions
const createMockAnalysisResult = (overrides: Partial<AnalysisResult> = {}): AnalysisResult => ({
  filePath: "test.md",
  result: {
    quality: buildQuality(85, 1, {
      grammarScore: 90,
      grammarIssues: 2,
      styleGuideScore: 88,
      styleGuideIssues: 1,
      terminologyScore: 95,
      terminologyIssues: 0,
    }),
    analysis: {
      clarity: buildClarity(78),
      tone: buildTone(82),
    },
  },
  issues: [],
  timestamp: "2024-01-15T10:30:00Z",
  ...overrides,
});

const createCommentData = (results: AnalysisResult[]): PRCommentData => ({
  owner: "test-owner",
  repo: "test-repo",
  prNumber: 123,
  results,
  config: {
    dialect: "american_english",
    tone: "formal",
    styleGuide: "ap",
  },
  eventType: "pull_request",
});

const createGitHubError = (message: string, status?: number): GitHubError => {
  const error = new Error(message) as GitHubError;
  if (status !== undefined) {
    error.status = status;
  }
  return error;
};

// Helper functions for common test setup - using explicit typing to avoid "never" issues
const setupSuccessfulRepositoryAccess = (): void => {
  const mockFn = mockOctokit.rest.repos.get;
  mockFn.mockResolvedValue({ data: {} });
};

const setupNoExistingComments = (): void => {
  const mockFn = mockOctokit.rest.issues.listComments;
  mockFn.mockResolvedValue({ data: [] });
};

const setupExistingComment = (commentId: number): void => {
  const mockFn = mockOctokit.rest.issues.listComments;
  mockFn.mockResolvedValue({
    data: [
      {
        id: commentId,
        body: '## <img src="https://github.com/markupai/content-guardian-action/raw/unlock%2FAdd-review-commit-with-suggestion/icons/markup_ai_mark_logo.svg" alt="Markup AI" width="28" height="28" /> Markup AI Analysis Results (DEV)\n\nThis comment was automatically generated by the Markup AI GitHub Action for **pull_request** event.\nSome old content',
      },
    ],
  });
};

const setupSuccessfulCommentCreation = (commentId: number): void => {
  const mockFn = mockOctokit.rest.issues.createComment;
  mockFn.mockResolvedValue({
    data: { id: commentId },
  });
};

const setupSuccessfulCommentUpdate = (commentId: number): void => {
  const mockFn = mockOctokit.rest.issues.updateComment;
  mockFn.mockResolvedValue({
    data: { id: commentId },
  });
};

describe("PR Comment Service", () => {
  beforeEach(() => {
    // Clear mock call history without clearing implementations
    mockOctokit.rest.repos.get.mockClear();
    mockOctokit.rest.issues.listComments.mockClear();
    mockOctokit.rest.issues.createComment.mockClear();
    mockOctokit.rest.issues.updateComment.mockClear();
    mockOctokit.rest.pulls.createReview.mockClear();
    mockOctokit.rest.pulls.createReviewComment.mockClear();
    mockOctokit.rest.pulls.listReviewComments.mockClear();
    vi.mocked(github.getOctokit).mockReturnValue(
      mockOctokit as unknown as ReturnType<typeof github.getOctokit>,
    );
  });

  describe("isPullRequestEvent", () => {
    it("should return true for pull_request event", () => {
      (github.context as MockGitHubContext).eventName = "pull_request";
      expect(isPullRequestEvent()).toBe(true);
    });

    it("should return false for push event", () => {
      (github.context as MockGitHubContext).eventName = "push";
      expect(isPullRequestEvent()).toBe(false);
    });
  });

  describe("getPRNumber", () => {
    it("should return null for non-pull_request event", () => {
      (github.context as MockGitHubContext).eventName = "push";
      expect(getPRNumber()).toBe(null);
    });
  });

  describe("createOrUpdatePRComment", () => {
    const mockResults = [createMockAnalysisResult()];
    const commentData = createCommentData(mockResults);

    describe("successful scenarios", () => {
      it("should create new comment when no existing comment found", async () => {
        setupSuccessfulRepositoryAccess();
        setupNoExistingComments();
        setupSuccessfulCommentCreation(456);

        await createOrUpdatePRComment(
          mockOctokit as unknown as ReturnType<typeof github.getOctokit>,
          commentData,
        );

        const createCall = mockOctokit.rest.issues.createComment.mock.calls[0][0] as {
          owner: string;
          repo: string;
          issue_number: number;
          body: string;
        };
        expect(createCall.owner).toBe("test-owner");
        expect(createCall.repo).toBe("test-repo");
        expect(createCall.issue_number).toBe(123);
        expect(createCall.body).toContain("## <img");
      });

      it("should update existing comment when found", async () => {
        setupSuccessfulRepositoryAccess();
        setupExistingComment(789);
        setupSuccessfulCommentUpdate(789);

        await createOrUpdatePRComment(
          mockOctokit as unknown as ReturnType<typeof github.getOctokit>,
          commentData,
        );

        const updateCall = mockOctokit.rest.issues.updateComment.mock.calls[0][0] as {
          owner: string;
          repo: string;
          comment_id: number;
          body: string;
        };
        expect(updateCall.owner).toBe("test-owner");
        expect(updateCall.repo).toBe("test-repo");
        expect(updateCall.comment_id).toBe(789);
        expect(updateCall.body).toContain("## <img");
      });
    });

    describe("error handling", () => {
      it("should handle permission denied error for repository access", async () => {
        const permissionError = createGitHubError("Permission denied", 403);
        const mockFn = mockOctokit.rest.repos.get;
        mockFn.mockRejectedValue(permissionError);

        await createOrUpdatePRComment(
          mockOctokit as unknown as ReturnType<typeof github.getOctokit>,
          commentData,
        );

        expect(mockOctokit.rest.issues.createComment).not.toHaveBeenCalled();
        expect(mockOctokit.rest.issues.updateComment).not.toHaveBeenCalled();
      });

      it("should handle permission denied error for comment creation", async () => {
        setupSuccessfulRepositoryAccess();
        setupNoExistingComments();

        const permissionError = createGitHubError("Permission denied", 403);
        const mockFn = mockOctokit.rest.issues.createComment;
        mockFn.mockRejectedValue(permissionError);

        await createOrUpdatePRComment(
          mockOctokit as unknown as ReturnType<typeof github.getOctokit>,
          commentData,
        );

        expect(mockOctokit.rest.issues.createComment).toHaveBeenCalled();
      });

      it("should handle pull request not found error", async () => {
        setupSuccessfulRepositoryAccess();
        setupNoExistingComments();

        const notFoundError = createGitHubError("Not found", 404);
        const mockFn = mockOctokit.rest.issues.createComment;
        mockFn.mockRejectedValue(notFoundError);

        await createOrUpdatePRComment(
          mockOctokit as unknown as ReturnType<typeof github.getOctokit>,
          commentData,
        );

        expect(mockOctokit.rest.issues.createComment).toHaveBeenCalled();
      });

      it("should handle generic error", async () => {
        setupSuccessfulRepositoryAccess();
        setupNoExistingComments();

        const genericError = createGitHubError("Something went wrong", 500);
        const mockFn = mockOctokit.rest.issues.createComment;
        mockFn.mockRejectedValue(genericError);

        await createOrUpdatePRComment(
          mockOctokit as unknown as ReturnType<typeof github.getOctokit>,
          commentData,
        );

        expect(mockOctokit.rest.issues.createComment).toHaveBeenCalled();
      });

      it("should handle error when finding existing comments", async () => {
        setupSuccessfulRepositoryAccess();
        const mockFn = mockOctokit.rest.issues.listComments;
        mockFn.mockRejectedValue(new Error("Failed to list comments"));
        setupSuccessfulCommentCreation(456);

        await createOrUpdatePRComment(
          mockOctokit as unknown as ReturnType<typeof github.getOctokit>,
          commentData,
        );

        expect(mockOctokit.rest.issues.createComment).toHaveBeenCalled();
      });
    });
  });

  describe("Comment content generation", () => {
    it("should generate proper markdown table with emojis", async () => {
      const mockResults = [createMockAnalysisResult()];
      const commentData = createCommentData(mockResults);

      setupSuccessfulRepositoryAccess();
      setupNoExistingComments();
      setupSuccessfulCommentCreation(456);

      await createOrUpdatePRComment(
        mockOctokit as unknown as ReturnType<typeof github.getOctokit>,
        commentData,
      );

      const createCall = mockOctokit.rest.issues.createComment.mock.calls[0][0] as { body: string };
      const commentBody = createCall.body;

      // Test header and structure
      expect(commentBody).toContain("## <img");
      expect(commentBody).toContain("## 游늵 Summary");
      expect(commentBody).toContain("Quality Score Legend: 游릭 80+ | 游리 60-79 | 游댮 0-59");

      // Test table structure
      expect(commentBody).toContain(
        "| File | Quality | Grammar | Consistency | Terminology | Clarity | Tone | Issues |",
      );

      // Test emoji display
      expect(commentBody).toContain("游릭 85"); // Green emoji for score 85

      // Test integer rounding in summary
      expect(commentBody).toContain("| Quality | 85 |");
      expect(commentBody).toContain("| Clarity | 78 |");
      expect(commentBody).toContain("| Grammar | 90 |");
      expect(commentBody).toContain("| Consistency | 88 |");
      expect(commentBody).toContain("| Tone | 82 |");
      expect(commentBody).toContain("| Terminology | 95 |");

      // Test configuration display
      expect(commentBody).toContain(
        "- **Configuration:** Style Guide: ap | Dialect: american_english | Tone: formal",
      );
    });

    it("should handle empty results", async () => {
      const commentData = createCommentData([]);

      setupSuccessfulRepositoryAccess();
      setupNoExistingComments();
      setupSuccessfulCommentCreation(456);

      await createOrUpdatePRComment(
        mockOctokit as unknown as ReturnType<typeof github.getOctokit>,
        commentData,
      );

      const createCall = mockOctokit.rest.issues.createComment.mock.calls[0][0] as { body: string };
      expect(createCall.body).toContain("No files were analyzed.");
    });

    it("should handle multiple files with different scores", async () => {
      const mockResults = [
        createMockAnalysisResult({
          filePath: "file1.md",
          result: {
            quality: {
              score: 95,
              grammar: { score: 90, issues: 2 },
              consistency: { score: 88, issues: 1 },
              terminology: { score: 95, issues: 0 },
            },
            analysis: {
              clarity: {
                score: 78,
                word_count: 100,
                sentence_count: 5,
                average_sentence_length: 20,
                flesch_reading_ease: 75,
                vocabulary_complexity: 0.3,
                sentence_complexity: 0.4,
              },
              tone: {
                score: 82,
                informality: 0.2,
                liveliness: 0.6,
                informality_alignment: 0.8,
                liveliness_alignment: 0.7,
              },
            },
          },
        }),
        createMockAnalysisResult({
          filePath: "file2.md",
          result: {
            quality: {
              score: 65,
              grammar: { score: 90, issues: 2 },
              consistency: { score: 88, issues: 1 },
              terminology: { score: 95, issues: 0 },
            },
            analysis: {
              clarity: {
                score: 78,
                word_count: 100,
                sentence_count: 5,
                average_sentence_length: 20,
                flesch_reading_ease: 75,
                vocabulary_complexity: 0.3,
                sentence_complexity: 0.4,
              },
              tone: {
                score: 82,
                informality: 0.2,
                liveliness: 0.6,
                informality_alignment: 0.8,
                liveliness_alignment: 0.7,
              },
            },
          },
        }),
        createMockAnalysisResult({
          filePath: "file3.md",
          result: {
            quality: {
              score: 45,
              grammar: { score: 90, issues: 2 },
              consistency: { score: 88, issues: 1 },
              terminology: { score: 95, issues: 0 },
            },
            analysis: {
              clarity: {
                score: 78,
                word_count: 100,
                sentence_count: 5,
                average_sentence_length: 20,
                flesch_reading_ease: 75,
                vocabulary_complexity: 0.3,
                sentence_complexity: 0.4,
              },
              tone: {
                score: 82,
                informality: 0.2,
                liveliness: 0.6,
                informality_alignment: 0.8,
                liveliness_alignment: 0.7,
              },
            },
          },
        }),
      ];
      const commentData = createCommentData(mockResults);

      setupSuccessfulRepositoryAccess();
      setupNoExistingComments();
      setupSuccessfulCommentCreation(456);

      await createOrUpdatePRComment(
        mockOctokit as unknown as ReturnType<typeof github.getOctokit>,
        commentData,
      );

      const createCall = mockOctokit.rest.issues.createComment.mock.calls[0][0] as { body: string };
      const commentBody = createCall.body;

      // Test different emoji colors for different scores
      expect(commentBody).toContain("游릭 95"); // Green for high score
      expect(commentBody).toContain("游리 65"); // Yellow for medium score
      expect(commentBody).toContain("游댮 45"); // Red for low score

      // Test average calculation (95 + 65 + 45) / 3 = 68.33... rounded to 68
      expect(commentBody).toContain("游리 68"); // Yellow for average score
    });
  });

  describe("createPRReviewComments", () => {
    it("should create review comments for issues", async () => {
      setupSuccessfulRepositoryAccess();
      setupNoExistingComments();

      const issueResult: AnalysisResult = createMockAnalysisResult({
        issues: [
          {
            line: 1,
            column: 0,
            lineText: "Teh sample line",
            issue: {
              original: "Teh",
              position: { start_index: 0 },
              subcategory: "spelling",
              category: IssueCategory.Grammar,
              suggestion: "The",
              severity: IssueSeverity.Low,
            },
          },
        ],
      });

      (github.context as { payload?: Record<string, unknown> }).payload = {
        pull_request: {
          head: { sha: "test-sha" },
        },
      };

      mockOctokit.paginate = vi.fn().mockResolvedValue([]);

      await createPRReviewComments(
        mockOctokit as unknown as ReturnType<typeof github.getOctokit>,
        createCommentData([issueResult]),
      );

      const reviewCall = mockOctokit.rest.pulls.createReview.mock.calls[0][0] as {
        owner: string;
        repo: string;
        pull_number: number;
        commit_id: string;
        event: string;
        comments: Array<{ path: string; line: number; side: string; body: string }>;
      };
      expect(reviewCall.owner).toBe("test-owner");
      expect(reviewCall.repo).toBe("test-repo");
      expect(reviewCall.pull_number).toBe(123);
      expect(reviewCall.commit_id).toBe("test-sha");
      expect(reviewCall.event).toBe("COMMENT");
      expect(reviewCall.comments[0].path).toBe("test.md");
      expect(reviewCall.comments[0].line).toBe(1);
      expect(reviewCall.comments[0].side).toBe("RIGHT");
      expect(reviewCall.comments[0].body).toContain("```suggestion");

      const createCall = mockOctokit.rest.pulls.createReview.mock.calls[0][0] as {
        comments: Array<{ body: string }>;
      };
      expect(createCall.comments[0].body).toContain("The sample line");
    });

    it("should skip review creation when no issues exist", async () => {
      (github.context as { payload?: Record<string, unknown> }).payload = {
        pull_request: {
          head: { sha: "test-sha" },
        },
      };

      await createPRReviewComments(
        mockOctokit as unknown as ReturnType<typeof github.getOctokit>,
        createCommentData([createMockAnalysisResult()]),
      );

      expect(mockOctokit.rest.pulls.createReview).not.toHaveBeenCalled();
    });

    it("should skip creating duplicate unresolved comments", async () => {
      setupSuccessfulRepositoryAccess();

      const issueResult: AnalysisResult = createMockAnalysisResult({
        issues: [
          {
            line: 1,
            column: 0,
            lineText: "Teh sample line",
            issue: {
              original: "Teh",
              position: { start_index: 0 },
              subcategory: "spelling",
              category: IssueCategory.Grammar,
              suggestion: "The",
              severity: IssueSeverity.Low,
            },
          },
        ],
      });

      (github.context as { payload?: Record<string, unknown> }).payload = {
        pull_request: {
          head: { sha: "test-sha" },
        },
      };

      const existingBody = `**Markup AI** detected issues:
- **Grammar / Spelling (Severity: Low)**: \`Teh\`
\`\`\`suggestion
The sample line
\`\`\``;
      mockOctokit.paginate = vi.fn().mockResolvedValue([
        {
          path: "test.md",
          line: 1,
          body: existingBody,
        },
      ]);

      await createPRReviewComments(
        mockOctokit as unknown as ReturnType<typeof github.getOctokit>,
        createCommentData([issueResult]),
      );

      expect(mockOctokit.rest.pulls.createReview).not.toHaveBeenCalled();
    });
  });
});
