/**
 * PR Comment service for managing comments on pull requests
 */

import * as core from "@actions/core";
import * as github from "@actions/github";
import { AnalysisIssue, AnalysisResult, AnalysisOptions } from "../types/index.js";
import { generateAnalysisContent, RepositoryContext } from "../utils/markdown-utils.js";
import { handleGitHubError, logError } from "../utils/error-utils.js";

/**
 * Interface for PR comment data
 */
export interface PRCommentData {
  owner: string;
  repo: string;
  prNumber: number;
  results: AnalysisResult[];
  config: AnalysisOptions;
  eventType: string;
}

interface ReviewCommentPayload {
  path: string;
  line: number;
  side: "RIGHT";
  body: string;
}

const MAX_REVIEW_COMMENTS = 50;
const MAX_ISSUES_PER_COMMENT = 5;
const MAX_ORIGINAL_LENGTH = 160;

/**
 * Generate complete comment body
 */
function generateCommentBody(
  results: AnalysisResult[],
  config: AnalysisOptions,
  eventType: string,
  context: RepositoryContext,
): string {
  const logoUrl =
    "https://github.com/markupai/content-guardian-action/raw/unlock%2FAdd-review-commit-with-suggestion/icons/markup_ai_mark_logo.svg";
  const header = `## ![Markup AI](${logoUrl}) Markup AI Analysis Results (DEV)

This comment was automatically generated by the Markup AI GitHub Action for **${eventType}** event.`;

  return generateAnalysisContent(results, config, header, eventType, context);
}

function truncateText(value: string, maxLength: number): string {
  if (value.length <= maxLength) {
    return value;
  }
  return `${value.slice(0, Math.max(0, maxLength - 3))}...`;
}

function applyInlineSuggestion(
  issue: AnalysisIssue["issue"],
  lineText: string,
  column: number,
): string | null {
  if (!("suggestion" in issue) || !issue.suggestion) {
    return null;
  }

  const original = issue.original;
  const suggestion = issue.suggestion;

  if (lineText) {
    const columnIndex = Math.min(Math.max(column, 0), lineText.length);
    const after = lineText.slice(columnIndex);
    if (after.startsWith(original)) {
      return `${lineText.slice(0, columnIndex)}${suggestion}${after.slice(original.length)}`;
    }

    const fallbackIndex = lineText.indexOf(original);
    if (fallbackIndex >= 0) {
      return `${lineText.slice(0, fallbackIndex)}${suggestion}${lineText.slice(
        fallbackIndex + original.length,
      )}`;
    }
  }

  return null;
}

function buildReviewCommentBody(issues: AnalysisIssue[]): string {
  const issueLines = issues
    .slice(0, MAX_ISSUES_PER_COMMENT)
    .map(({ issue, lineText, column }) => {
    const category = issue.category;
    const subcategory = issue.subcategory;
    const original = truncateText(issue.original, MAX_ORIGINAL_LENGTH);
    const inlineSuggestion = applyInlineSuggestion(issue, lineText, column);
    let suggestion = "";
    if (inlineSuggestion) {
      suggestion = `\n\`\`\`suggestion\n${inlineSuggestion}\n\`\`\``;
    } else if ("suggestion" in issue && issue.suggestion) {
      suggestion = `\nSuggestion: \`${truncateText(issue.suggestion, MAX_ORIGINAL_LENGTH)}\``;
    }
    return `- **${category} / ${subcategory}**: \`${original}\`${suggestion}`;
  });

  const moreCount = issues.length - issueLines.length;
  if (moreCount > 0) {
    issueLines.push(`- _${moreCount.toString()} more issue(s) on this line_`);
  }

  return `**Markup AI** detected issues:\n${issueLines.join("\n")}`;
}

function buildReviewComments(results: AnalysisResult[]): ReviewCommentPayload[] {
  const grouped = new Map<string, { path: string; line: number; issues: AnalysisIssue[] }>();

  for (const result of results) {
    for (const issue of result.issues) {
      if (!issue.line || issue.line <= 0) {
        continue;
      }
      const key = `${result.filePath}:${issue.line.toString()}`;
      const existing = grouped.get(key);
      if (existing) {
        existing.issues.push(issue);
      } else {
        grouped.set(key, { path: result.filePath, line: issue.line, issues: [issue] });
      }
    }
  }

  const comments: ReviewCommentPayload[] = [];
  for (const { path, line, issues } of grouped.values()) {
    if (comments.length >= MAX_REVIEW_COMMENTS) {
      break;
    }
    comments.push({
      path,
      line,
      side: "RIGHT",
      body: buildReviewCommentBody(issues),
    });
  }

  return comments;
}

/**
 * Find existing  comment on PR
 */
async function findExistingComment(
  octokit: ReturnType<typeof github.getOctokit>,
  owner: string,
  repo: string,
  prNumber: number,
): Promise<number | null> {
  try {
    const response = await octokit.rest.issues.listComments({
      owner,
      repo,
      issue_number: prNumber,
    });

    const comment = response.data.find((comment) =>
      comment.body?.includes("Markup AI Analysis Results"),
    );

    return comment?.id || null;
  } catch (error) {
    core.warning(`Failed to find existing comment: ${String(error)}`);
    return null;
  }
}

/**
 * Create or update PR comment with analysis results
 */
export async function createOrUpdatePRComment(
  octokit: ReturnType<typeof github.getOctokit>,
  commentData: PRCommentData,
): Promise<void> {
  const { owner, repo, prNumber, results, config } = commentData;

  try {
    // Check if we have permission to comment on PRs
    try {
      await octokit.rest.repos.get({
        owner,
        repo,
      });
    } catch (error: unknown) {
      const githubError = error as { status?: number };
      if (githubError.status === 403) {
        core.error(
          '❌ Permission denied: Cannot access repository. Make sure the GitHub token has "pull-requests: write" permission.',
        );
        return;
      }
      throw error;
    }

    const context: RepositoryContext = {
      owner,
      repo,
      prNumber,
      ref: github.context.ref,
      baseUrl: new URL(github.context.serverUrl),
    };
    const commentBody = generateCommentBody(results, config, commentData.eventType, context);
    const existingCommentId = await findExistingComment(octokit, owner, repo, prNumber);

    if (existingCommentId) {
      // Update existing comment
      await octokit.rest.issues.updateComment({
        owner,
        repo,
        comment_id: existingCommentId,
        body: commentBody,
      });
      core.info(`✅ Updated existing comment on PR #${prNumber.toString()}`);
    } else {
      // Create new comment
      await octokit.rest.issues.createComment({
        owner,
        repo,
        issue_number: prNumber,
        body: commentBody,
      });
      core.info(`✅ Created new comment on PR #${prNumber.toString()}`);
    }
  } catch (error: unknown) {
    const githubError = handleGitHubError(error, "Create/update PR comment");

    if (githubError.status === 403) {
      core.error("❌ Permission denied: Cannot create or update comments on pull requests.");
      core.error('Please ensure the GitHub token has "pull-requests: write" permission.');
    } else if (githubError.status === 404) {
      core.error("❌ Pull request not found. Make sure the PR exists and is accessible.");
    } else {
      logError(githubError, "Failed to create/update PR comment");
    }
  }
}

/**
 * Create PR review comments for issues found in analysis results
 */
export async function createPRReviewComments(
  octokit: ReturnType<typeof github.getOctokit>,
  commentData: PRCommentData,
): Promise<void> {
  const { owner, repo, prNumber, results } = commentData;
  const reviewComments = buildReviewComments(results);

  if (reviewComments.length === 0) {
    core.info("No review comments to create.");
    return;
  }

  const pullRequest = github.context.payload.pull_request;
  const commitId = pullRequest?.head?.sha;
  if (!commitId) {
    core.warning("Unable to determine PR head SHA for review comments.");
    return;
  }

  try {
    await octokit.rest.pulls.createReview({
      owner,
      repo,
      pull_number: prNumber,
      commit_id: commitId,
      event: "COMMENT",
      comments: reviewComments,
    });
    core.info(`✅ Created PR review with ${reviewComments.length.toString()} comments`);
  } catch (error: unknown) {
    const githubError = handleGitHubError(error, "Create PR review comments");
    if (githubError.status === 422) {
      core.warning(
        "Some review comments could not be placed in the PR diff. Retrying individually.",
      );
      for (const comment of reviewComments) {
        try {
          await octokit.rest.pulls.createReviewComment({
            owner,
            repo,
            pull_number: prNumber,
            commit_id: commitId,
            path: comment.path,
            line: comment.line,
            side: comment.side,
            body: comment.body,
          });
        } catch (commentError) {
          core.warning(
            `Failed to create review comment for ${comment.path}:${comment.line.toString()}: ${String(commentError)}`,
          );
        }
      }
      return;
    }
    if (githubError.status === 403) {
      core.error("❌ Permission denied: Cannot create PR review comments.");
      core.error('Please ensure the GitHub token has "pull-requests: write" permission.');
      return;
    }
    logError(githubError, "Failed to create PR review comments");
  }
}

/**
 * Check if current event is a pull request
 */
export function isPullRequestEvent(): boolean {
  return github.context.eventName === "pull_request";
}

/**
 * Get PR number from context
 */
export function getPRNumber(): number | null {
  if (github.context.eventName === "pull_request") {
    return github.context.issue.number;
  }
  return null;
}
